{"version":3,"file":"chartjs-plugin-zoom.min.js","sources":["../src/utils.ts","../src/state.ts","../src/scale.types.ts","../src/core.ts","../src/handlers.ts","../src/hammer.ts","../src/plugin.ts","../src/defaults.ts","../src/index.umd.ts"],"sourcesContent":["import type { Chart, Point, Scale } from 'chart.js'\nimport type { DragOptions, ModeOption, ModifierKey, PanOptions } from './options'\n\nconst eventKey = (key: ModifierKey): 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey' => `${key}Key`\n\nexport const getModifierKey = (opts?: DragOptions | PanOptions): ModifierKey | undefined =>\n  opts?.enabled && opts.modifierKey ? opts.modifierKey : undefined\nexport const keyPressed = (key: ModifierKey | undefined, event: TouchEvent | MouseEvent | PointerEvent) =>\n  key && event[eventKey(key)]\nexport const keyNotPressed = (key: ModifierKey | undefined, event: TouchEvent | MouseEvent | PointerEvent) =>\n  key && !event[eventKey(key)]\n\nexport function directionEnabled(mode: ModeOption | undefined, dir: 'x' | 'y', chart: Chart): boolean {\n  if (mode === undefined) {\n    return true\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1\n  } else if (typeof mode === 'function') {\n    return mode({ chart }).indexOf(dir) !== -1\n  }\n\n  return false\n}\n\nfunction directionsEnabled(mode: ModeOption | undefined, chart: Chart) {\n  if (typeof mode === 'function') {\n    mode = mode({ chart })\n  }\n  if (typeof mode === 'string') {\n    return { x: mode.indexOf('x') !== -1, y: mode.indexOf('y') !== -1 }\n  }\n\n  return { x: false, y: false }\n}\n\nexport function debounce(fn: () => void, delay: number | undefined) {\n  let timeout: number | NodeJS.Timeout\n  return function () {\n    clearTimeout(timeout)\n    timeout = setTimeout(fn, delay)\n    return delay\n  }\n}\n\nfunction getScaleUnderPoint({ x, y }: Point, chart: Chart): Scale | null {\n  const scales = chart.scales\n  const scaleIds = Object.keys(scales)\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]]\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale\n    }\n  }\n  return null\n}\n\ntype EnabledDirections = { x: boolean; y: boolean }\n\nconst convertOverScaleMode = (\n  chart: Chart,\n  overScaleMode: ModeOption | undefined,\n  scaleEnabled: EnabledDirections,\n  enabled: EnabledDirections\n) => {\n  if (!overScaleMode) {\n    return\n  }\n\n  const overScaleEnabled = directionsEnabled(overScaleMode, chart)\n  for (const axis of ['x', 'y'] as const) {\n    if (overScaleEnabled[axis]) {\n      scaleEnabled[axis] = enabled[axis]\n      enabled[axis] = false\n    }\n  }\n}\n\nconst getEnabledScales = (chart: Chart, enabled: EnabledDirections): Scale[] => {\n  const enabledScales: Scale[] = []\n\n  for (const scaleItem of Object.values(chart.scales)) {\n    if (enabled[scaleItem.axis as 'x' | 'y']) {\n      enabledScales.push(scaleItem)\n    }\n  }\n\n  return enabledScales || Object.values(chart.scales)\n}\n\n/**\n * Evaluate the chart's mode, scaleMode, and overScaleMode properties to\n * determine which axes are eligible for scaling.\n * options.overScaleMode can be a function if user want zoom only one scale of many for example.\n */\nexport function getEnabledScalesByPoint(options: PanOptions | undefined, point: Point, chart: Chart): Scale[] {\n  const { mode = 'xy', scaleMode, overScaleMode } = options || {}\n  const scale = getScaleUnderPoint(point, chart)\n\n  const enabled = directionsEnabled(mode, chart)\n  const scaleEnabled = directionsEnabled(scaleMode, chart)\n\n  // Convert deprecated overScaleEnabled to new scaleEnabled.\n  convertOverScaleMode(chart, overScaleMode, scaleEnabled, enabled)\n\n  if (scale && scaleEnabled[scale.axis as 'x' | 'y']) {\n    return [scale]\n  }\n\n  return getEnabledScales(chart, enabled)\n}\n","import { Chart, Scale, type Point } from 'chart.js'\nimport type { ZoomPluginOptions } from './options'\n\nexport type ScaleRange = { min: number; max: number }\nexport type OriginalLimits = { min: { scale?: number; options?: unknown }; max: { scale?: number; options?: unknown } }\nexport type OriginalScaleLimits = Record<string, OriginalLimits>\nexport type UpdatedScaleLimits = Record<string, ScaleRange>\n\nexport type HandlerFunctions = {\n  click: (chart: Chart, event: MouseEvent, options: ZoomPluginOptions) => void\n  keydown: (chart: Chart, event: KeyboardEvent) => void\n  mousedown: (chart: Chart, event: MouseEvent, options: ZoomPluginOptions) => void\n  mousemove: (chart: Chart, event: MouseEvent, options: ZoomPluginOptions) => void\n  mouseup: (chart: Chart, event: MouseEvent, options: ZoomPluginOptions) => void\n  onZoomComplete: ({ chart }: { chart: Chart }) => void\n  wheel: (chart: Chart, event: WheelEvent) => void\n}\nexport type HandlerName = keyof HandlerFunctions\nexport type HandlerFunction = HandlerFunctions[HandlerName]\nexport type Handler = EventListener\nexport type Handlers = Partial<Record<HandlerName, Handler>>\n\nexport type HandlerTarget = Partial<Record<HandlerName, HTMLCanvasElement | Document>>\n\nexport interface State {\n  originalScaleLimits: OriginalScaleLimits\n  updatedScaleLimits: UpdatedScaleLimits\n  handlers: Handlers\n  targets: HandlerTarget\n  panDelta: Record<string, number>\n  dragging: boolean\n  panning: boolean\n  options: ZoomPluginOptions\n  dragStart?: MouseEvent\n  dragEnd?: MouseEvent\n  filterNextClick?: boolean\n  scale?: number | null\n  delta?: Point | null\n  panScales?: Scale[]\n}\n\nconst chartStates = new WeakMap<Chart, State>()\n\nexport function getState(chart: Chart): State {\n  let state = chartStates.get(chart)\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      options: {},\n      targets: {},\n      panDelta: {},\n      dragging: false,\n      panning: false,\n    }\n    chartStates.set(chart, state)\n  }\n  return state\n}\n\nexport function removeState(chart: Chart) {\n  chartStates.delete(chart)\n}\n","import { almostEquals, isNullOrUndef, isNumber, valueOrDefault } from 'chart.js/helpers'\nimport { getState, type ScaleRange, type State } from './state'\nimport type { Point, Scale, TimeScale, TimeUnit } from 'chart.js'\nimport type { LimitOptions, ScaleLimits } from './options'\n\nexport type ZoomFunction = (scale: Scale, zoom: number, center: Point, limits: LimitOptions) => boolean\nexport type ZoomRectFunction = (scale: Scale, from: number, to: number, limits: LimitOptions) => boolean\nexport type PanFunction = (scale: Scale, delta: number, limits: LimitOptions) => boolean\n\nconst isTimeScale = (scale: Scale): scale is TimeScale => scale.type === 'time'\n\nconst isNotNumber = (value?: number): value is undefined => value === undefined || isNaN(value)\n\nexport function zoomDelta(\n  val: number | undefined,\n  min: number | undefined,\n  range: number,\n  newRange: number\n): ScaleRange {\n  const minPercent = range && isNumber(val) && isNumber(min) ? Math.max(0, Math.min(1, (val - min) / range)) : 0\n  const maxPercent = 1 - minPercent\n\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent,\n  }\n}\n\nfunction getValueAtPoint(scale: Scale, point: Point): number | undefined {\n  const pixel = scale.isHorizontal() ? point.x : point.y\n\n  return scale.getValueForPixel(pixel)\n}\n\nfunction linearZoomDelta(scale: Scale, zoom: number, center: Point): ScaleRange {\n  const range = scale.max - scale.min\n  const newRange = range * (zoom - 1)\n  const centerValue = getValueAtPoint(scale, center)\n\n  return zoomDelta(centerValue, scale.min, range, newRange)\n}\n\nfunction logarithmicZoomRange(scale: Scale, zoom: number, center: Point) {\n  const centerValue = getValueAtPoint(scale, center)\n\n  // Return the original range, if value could not be determined.\n  if (centerValue === undefined) {\n    return { min: scale.min, max: scale.max }\n  }\n\n  const logMin = Math.log10(scale.min)\n  const logMax = Math.log10(scale.max)\n  const logCenter = Math.log10(centerValue)\n  const logRange = logMax - logMin\n  const newLogRange = logRange * (zoom - 1)\n  const delta = zoomDelta(logCenter, logMin, logRange, newLogRange)\n\n  return {\n    min: Math.pow(10, logMin + delta.min),\n    max: Math.pow(10, logMax - delta.max),\n  }\n}\n\nfunction getScaleLimits(scale: Scale, limits?: LimitOptions): ScaleLimits {\n  return limits?.[scale.id] || limits?.[scale.axis] || {}\n}\n\nfunction getLimit(state: State, scale: Scale, scaleLimits: ScaleLimits, prop: 'min' | 'max', fallback: number): number {\n  let limit = scaleLimits[prop]\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop]\n    if (isNumber(original.options)) {\n      return original.options\n    }\n\n    if (!isNullOrUndef(original.options)) {\n      const parsed = scale.parse(original.options)\n      if (isNumber(parsed)) {\n        return parsed\n      }\n    }\n\n    limit = original.scale\n  }\n  return valueOrDefault(limit, fallback)\n}\n\nfunction linearRange(scale: Scale, pixel0: number, pixel1: number): ScaleRange {\n  const v0 = scale.getValueForPixel(pixel0) ?? scale.min\n  const v1 = scale.getValueForPixel(pixel1) ?? scale.max\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1),\n  }\n}\n\nfunction fixRange(\n  range: number,\n  { min, max, minLimit, maxLimit }: { min: number; max: number; minLimit: number; maxLimit: number },\n  state: State,\n  scale: Scale\n) {\n  const offset = (range - max + min) / 2\n  min -= offset\n  max += offset\n\n  // In case the values are really close to the original values, use the original values.\n  const origLimits: ScaleLimits = { min: 'original', max: 'original' }\n  const origMin = getLimit(state, scale, origLimits, 'min', -Infinity)\n  const origMax = getLimit(state, scale, origLimits, 'max', Infinity)\n\n  const epsilon = range / 1e6\n  if (almostEquals(min, origMin, epsilon)) {\n    min = origMin\n  }\n  if (almostEquals(max, origMax, epsilon)) {\n    max = origMax\n  }\n\n  // Apply limits\n  if (min < minLimit) {\n    min = minLimit\n    max = Math.min(minLimit + range, maxLimit)\n  } else if (max > maxLimit) {\n    max = maxLimit\n    min = Math.max(maxLimit - range, minLimit)\n  }\n\n  return { min, max }\n}\n\nexport function updateRange(\n  scale: Scale,\n  { min, max }: ScaleRange,\n  limits?: LimitOptions,\n  zoom: boolean | 'pan' = false\n): boolean {\n  const state = getState(scale.chart)\n  const { options: scaleOpts } = scale\n\n  const scaleLimits = getScaleLimits(scale, limits)\n  const { minRange = 0 } = scaleLimits\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity)\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity)\n\n  if (zoom === 'pan' && (min < minLimit || max > maxLimit)) {\n    // At limit: No change but return true to indicate no need to store the delta.\n    return true\n  }\n\n  const scaleRange = scale.max - scale.min\n  const range = zoom ? Math.max(max - min, minRange) : scaleRange\n\n  if (zoom && range === minRange && scaleRange <= minRange) {\n    // At range limit: No change but return true to indicate no need to store the delta.\n    return true\n  }\n\n  const newRange = fixRange(range, { min, max, minLimit, maxLimit }, state, scale)\n\n  scaleOpts.min = newRange.min\n  scaleOpts.max = newRange.max\n\n  state.updatedScaleLimits[scale.id] = newRange\n\n  // return true if the scale range is changed\n  return scale.parse(newRange.min) !== scale.min || scale.parse(newRange.max) !== scale.max\n}\n\nfunction zoomNumericalScale(scale: Scale, zoom: number, center: Point, limits: LimitOptions) {\n  const delta = linearZoomDelta(scale, zoom, center)\n  const newRange = { min: scale.min + delta.min, max: scale.max - delta.max }\n  return updateRange(scale, newRange, limits, true)\n}\n\nfunction zoomLogarithmicScale(scale: Scale, zoom: number, center: Point, limits: LimitOptions) {\n  const newRange = logarithmicZoomRange(scale, zoom, center)\n  return updateRange(scale, newRange, limits, true)\n}\n\nfunction zoomRectNumericalScale(scale: Scale, from: number, to: number, limits: LimitOptions) {\n  return updateRange(scale, linearRange(scale, from, to), limits, true)\n}\n\nconst integerChange = (v: number) =>\n  v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1)\n\nfunction existCategoryFromMaxZoom(scale: Scale) {\n  const labels = scale.getLabels()\n  const maxIndex = labels.length - 1\n\n  if (scale.min > 0) {\n    scale.min -= 1\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1\n  }\n}\n\nfunction zoomCategoryScale(scale: Scale, zoom: number, center: Point, limits: LimitOptions) {\n  const delta = linearZoomDelta(scale, zoom, center)\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale)\n  }\n  const newRange = { min: scale.min + integerChange(delta.min), max: scale.max - integerChange(delta.max) }\n\n  return updateRange(scale, newRange, limits, true)\n}\n\nfunction scaleLength(scale: Scale) {\n  return scale.isHorizontal() ? scale.width : scale.height\n}\n\nfunction panCategoryScale(scale: Scale, delta: number, limits: LimitOptions) {\n  const labels = scale.getLabels()\n  const lastLabelIndex = labels.length - 1\n  let { min, max } = scale\n  // The visible range. Ticks can be skipped, and thus not reliable.\n  const range = Math.max(max - min, 1)\n  // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10))\n  const stepSize = Math.round(Math.abs(delta / stepDelta))\n  let applied\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex)\n    min = range === 1 ? max : max - range\n    applied = max === lastLabelIndex\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize)\n    max = range === 1 ? min : min + range\n    applied = min === 0\n  }\n\n  return updateRange(scale, { min, max }, limits) || Boolean(applied)\n}\n\nconst OFFSETS: Record<TimeUnit, number> = {\n  millisecond: 0,\n  second: 500, // 500 ms\n  minute: 30 * 1000, // 30 s\n  hour: 30 * 60 * 1000, // 30 m\n  day: 12 * 60 * 60 * 1000, // 12 h\n  week: 3.5 * 24 * 60 * 60 * 1000, // 3.5 d\n  month: 15 * 24 * 60 * 60 * 1000, // 15 d\n  quarter: 60 * 24 * 60 * 60 * 1000, // 60 d\n  year: 182 * 24 * 60 * 60 * 1000, // 182 d\n}\n\nfunction panNumericalScale(scale: Scale, delta: number, limits: LimitOptions, pan = false) {\n  const { min: prevStart, max: prevEnd } = scale\n  let offset = 0\n  if (isTimeScale(scale)) {\n    const round = scale.options.time?.round\n    offset = round ? OFFSETS[round] : 0\n  }\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta)\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta)\n  if (isNotNumber(newMin) || isNotNumber(newMax)) {\n    // NaN can happen for 0-dimension scales (either because they were configured\n    // with min === max or because the chart has 0 plottable area).\n    return true\n  }\n  return updateRange(scale, { min: newMin, max: newMax }, limits, pan ? 'pan' : false)\n}\n\nfunction panNonLinearScale(scale: Scale, delta: number, limits: LimitOptions) {\n  return panNumericalScale(scale, delta, limits, true)\n}\n\nexport const zoomFunctions: Record<string, ZoomFunction> = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale,\n  logarithmic: zoomLogarithmicScale,\n}\n\nexport const zoomRectFunctions: Record<string, ZoomRectFunction> = {\n  default: zoomRectNumericalScale,\n}\n\nexport const panFunctions: Record<string, PanFunction> = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale,\n}\n","import { isNumber, sign } from 'chart.js/helpers'\nimport { panFunctions, updateRange, zoomFunctions, zoomRectFunctions } from './scale.types.js'\nimport { getState, type OriginalScaleLimits, type ScaleRange, type State, type UpdatedScaleLimits } from './state.js'\nimport { directionEnabled, getEnabledScalesByPoint } from './utils.js'\nimport type { Chart, Point, Scale, UpdateMode } from 'chart.js'\nimport type { LimitOptions, ZoomTrigger } from './options.js'\nimport type { ZoomAmount } from './types.js'\n\nfunction shouldUpdateScaleLimits(\n  scale: Scale,\n  originalScaleLimits: OriginalScaleLimits,\n  updatedScaleLimits: UpdatedScaleLimits\n) {\n  const {\n    id,\n    options: { min, max },\n  } = scale\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true\n  }\n  const previous = updatedScaleLimits[id]\n  return previous.min !== min || previous.max !== max\n}\n\nfunction removeMissingScales(limits: OriginalScaleLimits | UpdatedScaleLimits, scales: Record<string, Scale>) {\n  for (const key of Object.keys(limits)) {\n    if (!scales[key]) {\n      delete limits[key]\n    }\n  }\n}\n\nfunction storeOriginalScaleLimits(chart: Chart, state: State) {\n  const { scales } = chart\n  const { originalScaleLimits, updatedScaleLimits } = state\n\n  for (const scale of Object.values(scales)) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: { scale: scale.min, options: scale.options.min },\n        max: { scale: scale.max, options: scale.options.max },\n      }\n    }\n  }\n\n  removeMissingScales(originalScaleLimits, scales)\n  removeMissingScales(updatedScaleLimits, scales)\n  return originalScaleLimits\n}\n\nfunction doZoom(scale: Scale, amount: number, center: Point, limits: LimitOptions) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default\n  fn?.(scale, amount, center, limits)\n}\n\nfunction doZoomRect(scale: Scale, from: number, to: number, limits: LimitOptions) {\n  const fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default\n  fn?.(scale, from, to, limits)\n}\n\nfunction getCenter(chart: Chart) {\n  const ca = chart.chartArea\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2,\n  }\n}\n\nexport function zoom(chart: Chart, amount: ZoomAmount, transition: UpdateMode = 'none', trigger: ZoomTrigger = 'api') {\n  const { x = 1, y = 1, focalPoint = getCenter(chart) } = typeof amount === 'number' ? { x: amount, y: amount } : amount\n  const state = getState(chart)\n  const {\n    options: { limits = {}, zoom: zoomOptions },\n  } = state\n\n  storeOriginalScaleLimits(chart, state)\n\n  const xEnabled = x !== 1\n  const yEnabled = y !== 1\n  const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart)\n\n  for (const scale of enabledScales) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits)\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits)\n    }\n  }\n\n  chart.update(transition)\n\n  zoomOptions?.onZoom?.({ chart, trigger })\n}\n\nexport function zoomRect(\n  chart: Chart,\n  p0: Point,\n  p1: Point,\n  transition: UpdateMode = 'none',\n  trigger: ZoomTrigger = 'api'\n) {\n  const state = getState(chart)\n  const {\n    options: { limits = {}, zoom: zoomOptions = {} },\n  } = state\n  const { mode = 'xy' } = zoomOptions\n\n  storeOriginalScaleLimits(chart, state)\n  const xEnabled = directionEnabled(mode, 'x', chart)\n  const yEnabled = directionEnabled(mode, 'y', chart)\n\n  for (const scale of Object.values(chart.scales)) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoomRect(scale, p0.x, p1.x, limits)\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoomRect(scale, p0.y, p1.y, limits)\n    }\n  }\n\n  chart.update(transition)\n\n  zoomOptions.onZoom?.({ chart, trigger })\n}\n\nexport function zoomScale(\n  chart: Chart,\n  scaleId: string,\n  range: ScaleRange,\n  transition: UpdateMode = 'none',\n  trigger: ZoomTrigger = 'api'\n) {\n  const state = getState(chart)\n  storeOriginalScaleLimits(chart, state)\n  const scale = chart.scales[scaleId]\n  updateRange(scale, range, undefined, true)\n  chart.update(transition)\n\n  state.options.zoom?.onZoom?.({ chart, trigger })\n}\n\nexport function resetZoom(chart: Chart, transition: UpdateMode = 'default') {\n  const state = getState(chart)\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state)\n\n  for (const scale of Object.values(chart.scales)) {\n    const scaleOptions = scale.options\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options\n      scaleOptions.max = originalScaleLimits[scale.id].max.options\n    } else {\n      delete scaleOptions.min\n      delete scaleOptions.max\n    }\n    delete state.updatedScaleLimits[scale.id]\n  }\n  chart.update(transition)\n\n  state.options.zoom?.onZoomComplete?.({ chart })\n}\n\nfunction getOriginalRange(state: State, scaleId: string): number | undefined {\n  const original = state.originalScaleLimits[scaleId]\n  if (!original) {\n    return undefined\n  }\n  const { min, max } = original\n  if (isNumber(max.options) && isNumber(min.options)) {\n    return max.options - min.options\n  }\n  if (isNumber(max.scale) && isNumber(min.scale)) {\n    return max.scale - min.scale\n  }\n  return undefined\n}\n\nexport function getZoomLevel(chart: Chart) {\n  const state = getState(chart)\n  let min = 1\n  let max = 1\n  for (const scale of Object.values(chart.scales)) {\n    const origRange = getOriginalRange(state, scale.id)\n    if (origRange) {\n      const level = Math.round((origRange / (scale.max - scale.min)) * 100) / 100\n      min = Math.min(min, level)\n      max = Math.max(max, level)\n    }\n  }\n  return min < 1 ? min : max\n}\n\nfunction panScale(scale: Scale, delta: number, limits: LimitOptions, state: State) {\n  const { panDelta } = state\n  // Add possible cumulative delta from previous pan attempts where scale did not change\n  const storedDelta = panDelta[scale.id] || 0\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default\n  if (fn?.(scale, delta, limits)) {\n    // The scale changed, reset cumulative delta\n    panDelta[scale.id] = 0\n  } else {\n    // The scale did not change, store cumulative delta\n    panDelta[scale.id] = delta\n  }\n}\n\ntype PanAmount = number | Partial<Point>\n\nexport function pan(chart: Chart, delta: PanAmount, enabledScales?: Scale[], transition: UpdateMode = 'none') {\n  const { x = 0, y = 0 } = typeof delta === 'number' ? { x: delta, y: delta } : delta\n  const state = getState(chart)\n  const {\n    options: { pan: panOptions, limits = {} },\n  } = state\n  const { onPan } = panOptions || {}\n\n  storeOriginalScaleLimits(chart, state)\n\n  const xEnabled = x !== 0\n  const yEnabled = y !== 0\n\n  const scales = enabledScales || Object.values(chart.scales)\n\n  for (const scale of scales) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state)\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state)\n    }\n  }\n\n  chart.update(transition)\n\n  onPan?.({ chart })\n}\n\nexport function getInitialScaleBounds(chart: Chart) {\n  const state = getState(chart)\n  storeOriginalScaleLimits(chart, state)\n  const scaleBounds: Record<string, { min?: number; max?: number }> = {}\n  for (const scaleId of Object.keys(chart.scales)) {\n    const { min, max } = state.originalScaleLimits[scaleId] || { min: {}, max: {} }\n    scaleBounds[scaleId] = { min: min.scale, max: max.scale }\n  }\n\n  return scaleBounds\n}\n\nexport function getZoomedScaleBounds(chart: Chart) {\n  const state = getState(chart)\n  const scaleBounds: Record<string, { min?: number; max?: number }> = {}\n  for (const scaleId of Object.keys(chart.scales)) {\n    scaleBounds[scaleId] = state.updatedScaleLimits[scaleId]\n  }\n\n  return scaleBounds\n}\n\nexport function isZoomedOrPanned(chart: Chart) {\n  const scaleBounds = getInitialScaleBounds(chart)\n  for (const scaleId of Object.keys(chart.scales)) {\n    const { min: originalMin, max: originalMax } = scaleBounds[scaleId]\n\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\n      return true\n    }\n\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\n      return true\n    }\n  }\n\n  return false\n}\n\nexport function isZoomingOrPanningState(state: State) {\n  return state.panning || state.dragging\n}\n\nexport function isZoomingOrPanning(chart: Chart) {\n  const state = getState(chart)\n  // From the perspective of outside callers, zooming and panning are still\n  // active if we haven't yet cleared the next click.\n  return !!(isZoomingOrPanningState(state) || state.filterNextClick)\n}\n","import { directionEnabled, debounce, keyNotPressed, getModifierKey, keyPressed } from './utils'\nimport { zoom, zoomRect } from './core'\nimport { getRelativePosition, _isPointInArea } from 'chart.js/helpers'\nimport { getState, type HandlerFunctions, type HandlerName } from './state'\nimport type { Chart, ChartArea, Point } from 'chart.js'\nimport type { ModeOption, ZoomOptions, ZoomPluginOptions } from './options'\n\nconst clamp = (x: number, from: number, to: number): number => Math.min(to, Math.max(from, x))\n\nfunction removeHandler(chart: Chart, type: HandlerName) {\n  const { handlers, targets } = getState(chart)\n  const handler = handlers[type]\n  const target = targets[type]\n  if (handler && target) {\n    target.removeEventListener(type, handler)\n    delete handlers[type]\n  }\n}\n\ntype EventHandler<T extends Event> = (chart: Chart, event: T, options: ZoomPluginOptions) => void\n\nfunction addHandler<T extends Event>(\n  chart: Chart,\n  target: HTMLCanvasElement | Document,\n  type: HandlerName,\n  handler: EventHandler<T>\n) {\n  const { handlers, options, targets } = getState(chart)\n  const oldHandler = handlers[type]\n  if (oldHandler && targets[type] === target) {\n    // already attached\n    return\n  }\n  removeHandler(chart, type)\n  const listener = (handlers[type] = (event) => handler(chart, event as T, options))\n  targets[type] = target\n\n  // `passive: false` for wheel events, to prevent chrome warnings. Use default value for other events.\n  const passive = type === 'wheel' ? false : undefined\n  target.addEventListener(type, listener, { passive })\n}\n\nexport function mouseMove(chart: Chart, event: MouseEvent) {\n  const state = getState(chart)\n  if (state.dragStart) {\n    state.dragging = true\n    state.dragEnd = event\n    // chart.update('none')\n  }\n}\n\nfunction keyDown(chart: Chart, event: KeyboardEvent) {\n  const state = getState(chart)\n  if (!state.dragStart || event.key !== 'Escape') {\n    return\n  }\n\n  removeHandler(chart, 'keydown')\n  state.dragging = false\n  state.dragStart = state.dragEnd = undefined\n  chart.update('none')\n}\n\nfunction getPointPosition(event: MouseEvent, chart: Chart) {\n  if (event.target !== chart.canvas) {\n    const canvasArea = chart.canvas.getBoundingClientRect()\n    return {\n      x: event.clientX - canvasArea.left,\n      y: event.clientY - canvasArea.top,\n    }\n  }\n  return getRelativePosition(event, chart as any) // TODO: would expect Chart type to be valid for getRelativePosition\n}\n\nfunction zoomStart(chart: Chart, event: MouseEvent, zoomOptions: ZoomOptions): boolean | void {\n  const { onZoomStart, onZoomRejected } = zoomOptions\n  if (onZoomStart) {\n    const point = getPointPosition(event, chart)\n    if (onZoomStart?.({ chart, event, point }) === false) {\n      onZoomRejected?.({ chart, event })\n      return false\n    }\n  }\n}\n\nexport function mouseDown(chart: Chart, event: MouseEvent): void {\n  if (chart.legend) {\n    const point = getRelativePosition(event, chart as any) // TODO: would expect Chart type to be valid for getRelativePosition\n    if (_isPointInArea(point, chart.legend)) {\n      return\n    }\n  }\n  const state = getState(chart)\n  const { pan: panOptions, zoom: zoomOptions = {} } = state.options\n  if (\n    event.button !== 0 ||\n    keyPressed(getModifierKey(panOptions), event) ||\n    keyNotPressed(getModifierKey(zoomOptions.drag), event)\n  ) {\n    return zoomOptions.onZoomRejected?.({ chart, event })\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return\n  }\n  state.dragStart = event\n\n  addHandler(chart, chart.canvas.ownerDocument, 'mousemove', mouseMove)\n  addHandler(chart, window.document, 'keydown', keyDown)\n}\n\nfunction applyAspectRatio(\n  { begin, end }: { begin: { x: number; y: number }; end: { x: number; y: number } },\n  aspectRatio: number\n) {\n  let width = end.x - begin.x\n  let height = end.y - begin.y\n  const ratio = Math.abs(width / height)\n\n  if (ratio > aspectRatio) {\n    width = Math.sign(width) * Math.abs(height * aspectRatio)\n  } else if (ratio < aspectRatio) {\n    height = Math.sign(height) * Math.abs(width / aspectRatio)\n  }\n\n  end.x = begin.x + width\n  end.y = begin.y + height\n}\n\ntype Rect = { top?: number; left?: number; right?: number; bottom?: number }\nfunction applyMinMaxProps(\n  rect: Rect,\n  chartArea: ChartArea,\n  points: { begin: Point; end: Point },\n  { min, max, prop }: { min: keyof Rect; max: keyof Rect; prop: 'x' | 'y' }\n) {\n  rect[min] = clamp(Math.min(points.begin[prop], points.end[prop]), chartArea[min], chartArea[max])\n  rect[max] = clamp(Math.max(points.begin[prop], points.end[prop]), chartArea[min], chartArea[max])\n}\n\nfunction getRelativePoints(\n  chart: Chart,\n  pointEvents: { dragStart: MouseEvent; dragEnd: MouseEvent },\n  maintainAspectRatio?: boolean\n) {\n  const points = {\n    begin: getPointPosition(pointEvents.dragStart, chart),\n    end: getPointPosition(pointEvents.dragEnd, chart),\n  }\n\n  if (maintainAspectRatio) {\n    const aspectRatio = chart.chartArea.width / chart.chartArea.height\n    applyAspectRatio(points, aspectRatio)\n  }\n\n  return points\n}\n\nexport function computeDragRect(\n  chart: Chart,\n  mode: ModeOption | undefined,\n  pointEvents: { dragStart: MouseEvent; dragEnd: MouseEvent },\n  maintainAspectRatio: boolean | undefined\n) {\n  const xEnabled = directionEnabled(mode, 'x', chart)\n  const yEnabled = directionEnabled(mode, 'y', chart)\n  const { top, left, right, bottom, width: chartWidth, height: chartHeight } = chart.chartArea\n  const rect = { top, left, right, bottom }\n\n  const points = getRelativePoints(chart, pointEvents, maintainAspectRatio && xEnabled && yEnabled)\n\n  if (xEnabled) {\n    applyMinMaxProps(rect, chart.chartArea, points, { min: 'left', max: 'right', prop: 'x' })\n  }\n\n  if (yEnabled) {\n    applyMinMaxProps(rect, chart.chartArea, points, { min: 'top', max: 'bottom', prop: 'y' })\n  }\n\n  const width = rect.right - rect.left\n  const height = rect.bottom - rect.top\n\n  return {\n    ...rect,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + (chartWidth - width) / chartWidth : 1,\n    zoomY: yEnabled && height ? 1 + (chartHeight - height) / chartHeight : 1,\n  }\n}\n\nexport function mouseUp(chart: Chart, event: MouseEvent) {\n  const state = getState(chart)\n  if (!state.dragStart) {\n    return\n  }\n\n  removeHandler(chart, 'mousemove')\n  const { mode, onZoomComplete, drag } = state.options.zoom ?? {}\n  const { threshold = 0, maintainAspectRatio } = drag ?? {}\n  const rect = computeDragRect(chart, mode, { dragStart: state.dragStart, dragEnd: event }, maintainAspectRatio)\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY)\n\n  // Remove drag start and end before chart update to stop drawing selected area\n  state.dragStart = state.dragEnd = undefined\n\n  if (distance <= threshold) {\n    state.dragging = false\n    chart.update('none')\n    return\n  }\n\n  zoomRect(chart, { x: rect.left, y: rect.top }, { x: rect.right, y: rect.bottom }, 'zoom', 'drag')\n\n  state.dragging = false\n  state.filterNextClick = true\n  onZoomComplete?.({ chart })\n}\n\nfunction wheelPreconditions(chart: Chart, event: WheelEvent, zoomOptions: ZoomOptions): true | void {\n  // Before preventDefault, check if the modifier key required and pressed\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    zoomOptions.onZoomRejected?.({ chart, event })\n    return\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return\n  }\n\n  // Prevent the event from triggering the default behavior (e.g. content scrolling).\n  if (event.cancelable) {\n    event.preventDefault()\n  }\n\n  // Firefox always fires the wheel event twice:\n  // First without the delta and right after that once with the delta properties.\n  if (event.deltaY === undefined) {\n    return\n  }\n  return true\n}\n\nexport function wheel(chart: Chart, event: WheelEvent & { target?: HTMLCanvasElement }) {\n  const {\n    handlers: { onZoomComplete },\n    options: { zoom: zoomOptions = {} },\n  } = getState(chart)\n\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return\n  }\n\n  const rect = event.target?.getBoundingClientRect()\n  const speed = zoomOptions?.wheel?.speed ?? 0.1\n  const percentage = event.deltaY >= 0 ? 2 - 1 / (1 - speed) : 1 + speed\n  const amount = {\n    x: percentage,\n    y: percentage,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top,\n    },\n  }\n\n  zoom(chart, amount, 'zoom', 'wheel')\n\n  onZoomComplete?.(event)\n}\n\nfunction addDebouncedHandler(\n  chart: Chart,\n  name: HandlerName,\n  handler: HandlerFunctions['onZoomComplete'] | undefined,\n  delay: number\n) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => handler?.({ chart }), delay)\n  }\n}\n\nexport function addListeners(chart: Chart, options: ZoomPluginOptions) {\n  const canvas = chart.canvas\n  const { wheel: wheelOptions, drag: dragOptions, onZoomComplete } = options.zoom ?? {}\n\n  // Install listeners. Do this dynamically based on options so that we can turn zoom on and off\n  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page\n  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled\n  if (wheelOptions?.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel)\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250)\n  } else {\n    removeHandler(chart, 'wheel')\n  }\n  if (dragOptions?.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown)\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp)\n  } else {\n    removeHandler(chart, 'mousedown')\n    removeHandler(chart, 'mousemove')\n    removeHandler(chart, 'mouseup')\n    removeHandler(chart, 'keydown')\n  }\n}\n\nexport function removeListeners(chart: Chart) {\n  removeHandler(chart, 'mousedown')\n  removeHandler(chart, 'mousemove')\n  removeHandler(chart, 'mouseup')\n  removeHandler(chart, 'wheel')\n  removeHandler(chart, 'click')\n  removeHandler(chart, 'keydown')\n}\n","import { getRelativePosition } from 'chart.js/helpers'\nimport Hammer from 'hammerjs'\nimport { pan, zoom } from './core'\nimport { getState, type State } from './state'\nimport { directionEnabled, getEnabledScalesByPoint, getModifierKey, keyNotPressed, keyPressed } from './utils'\nimport type { Chart } from 'chart.js'\nimport type { ZoomPluginOptions } from './options'\n\nfunction createEnabler(chart: Chart, state: State) {\n  return function (_recognizer: any, event: HammerInput) {\n    const { pan: panOptions, zoom: zoomOptions = {} } = state.options\n    if (!panOptions || !panOptions.enabled) {\n      return false\n    }\n    const srcEvent = event && event.srcEvent\n    if (!srcEvent) {\n      // Sometimes Hammer queries this with a null event.\n      return true\n    }\n    if (\n      !state.panning &&\n      event.pointerType === 'mouse' &&\n      (keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))\n    ) {\n      panOptions.onPanRejected?.({ chart, event })\n      return false\n    }\n    return true\n  }\n}\n\nfunction pinchAxes(p0: { clientX: number; clientY: number }, p1: { clientX: number; clientY: number }) {\n  // fingers position difference\n  const pinchX = Math.abs(p0.clientX - p1.clientX)\n  const pinchY = Math.abs(p0.clientY - p1.clientY)\n\n  // diagonal fingers will change both (xy) axes\n  const p = pinchX / pinchY\n  let x, y\n  if (p > 0.3 && p < 1.7) {\n    x = y = true\n  } else if (pinchX > pinchY) {\n    x = true\n  } else {\n    y = true\n  }\n  return { x, y }\n}\n\nfunction handlePinch(chart: Chart, state: State, e: HammerInput) {\n  if (state.scale) {\n    const { center, pointers } = e\n    // Hammer reports the total scaling. We need the incremental amount\n    const zoomPercent = (1 / state.scale) * e.scale\n    const rect = e.target.getBoundingClientRect()\n    const pinch = pinchAxes(pointers[0], pointers[1])\n    const mode = state.options.zoom?.mode\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top,\n      },\n    }\n\n    zoom(chart, amount, 'zoom', 'pinch')\n\n    // Keep track of overall scale\n    state.scale = e.scale\n  }\n}\n\nfunction startPinch(chart: Chart, state: State, e: HammerInput) {\n  if (state.options.zoom?.pinch?.enabled) {\n    const point = getRelativePosition(e.srcEvent, chart as any) // TODO: would expect Chart type to be valid for getRelativePosition\n    if (state.options.zoom?.onZoomStart?.({ chart, event: e.srcEvent, point }) === false) {\n      state.scale = null\n      state.options.zoom?.onZoomRejected?.({ chart, event: e.srcEvent })\n    } else {\n      state.scale = 1\n    }\n  }\n}\n\nfunction endPinch(chart: Chart, state: State, e: HammerInput) {\n  if (state.scale) {\n    handlePinch(chart, state, e)\n    state.scale = null // reset\n    state.options.zoom?.onZoomComplete?.({ chart })\n  }\n}\n\nfunction handlePan(chart: Chart, state: State, e: HammerInput) {\n  const delta = state.delta\n  if (delta) {\n    state.panning = true\n    pan(chart, { x: e.deltaX - delta.x, y: e.deltaY - delta.y }, state.panScales)\n    state.delta = { x: e.deltaX, y: e.deltaY }\n  }\n}\n\nfunction startPan(chart: Chart, state: State, event: HammerInput) {\n  const { enabled, onPanStart, onPanRejected } = state.options.pan ?? {}\n  if (!enabled) {\n    return\n  }\n  const rect = event.target.getBoundingClientRect()\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top,\n  }\n\n  if (onPanStart?.({ chart, event, point }) === false) {\n    return onPanRejected?.({ chart, event })\n  }\n\n  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart)\n  state.delta = { x: 0, y: 0 }\n  handlePan(chart, state, event)\n}\n\nfunction endPan(chart: Chart, state: State) {\n  state.delta = null\n  if (state.panning) {\n    state.panning = false\n    state.filterNextClick = true\n    state.options.pan?.onPanComplete?.({ chart })\n  }\n}\n\nconst hammers = new WeakMap()\nexport function startHammer(chart: Chart, options: ZoomPluginOptions) {\n  const state = getState(chart)\n  const canvas = chart.canvas\n  const { pan: panOptions, zoom: zoomOptions } = options\n\n  const mc = new Hammer.Manager(canvas)\n  if (zoomOptions?.pinch?.enabled) {\n    mc.add(new Hammer.Pinch())\n    mc.on('pinchstart', (e) => startPinch(chart, state, e))\n    mc.on('pinch', (e) => handlePinch(chart, state, e))\n    mc.on('pinchend', (e) => endPinch(chart, state, e))\n  }\n\n  if (panOptions && panOptions.enabled) {\n    mc.add(\n      new Hammer.Pan({\n        threshold: panOptions.threshold,\n        enable: createEnabler(chart, state),\n      })\n    )\n    mc.on('panstart', (e) => startPan(chart, state, e))\n    mc.on('panmove', (e) => handlePan(chart, state, e))\n    mc.on('panend', () => endPan(chart, state))\n  }\n\n  hammers.set(chart, mc)\n}\n\nexport function stopHammer(chart: Chart) {\n  const mc = hammers.get(chart)\n  if (mc) {\n    mc.remove('pinchstart')\n    mc.remove('pinch')\n    mc.remove('pinchend')\n    mc.remove('panstart')\n    mc.remove('pan')\n    mc.remove('panend')\n    mc.destroy()\n    hammers.delete(chart)\n  }\n}\n\nexport function hammerOptionsChanged(oldOptions: ZoomPluginOptions, newOptions: ZoomPluginOptions) {\n  const { pan: oldPan, zoom: oldZoom } = oldOptions\n  const { pan: newPan, zoom: newZoom } = newOptions\n\n  if (oldZoom?.pinch?.enabled !== newZoom?.pinch?.enabled) {\n    return true\n  }\n  if (oldPan?.enabled !== newPan?.enabled) {\n    return true\n  }\n  if (oldPan?.threshold !== newPan?.threshold) {\n    return true\n  }\n\n  return false\n}\n","import Hammer from 'hammerjs'\nimport { addListeners, computeDragRect, removeListeners } from './handlers'\nimport { hammerOptionsChanged, startHammer, stopHammer } from './hammer'\nimport {\n  pan,\n  zoom,\n  resetZoom,\n  zoomScale,\n  getZoomLevel,\n  getInitialScaleBounds,\n  getZoomedScaleBounds,\n  isZoomedOrPanned,\n  isZoomingOrPanning,\n  isZoomingOrPanningState,\n  zoomRect,\n} from './core'\nimport { panFunctions, zoomFunctions, zoomRectFunctions } from './scale.types'\nimport { getState, removeState } from './state'\nimport { version } from '../package.json'\nimport type { Chart, ChartEvent } from 'chart.js'\nimport type { ZoomPluginOptions } from './options'\nimport { defaults } from './defaults'\n\nfunction draw(chart: Chart, caller: string, options: ZoomPluginOptions) {\n  const dragOptions = options.zoom?.drag\n  const { dragStart, dragEnd } = getState(chart)\n\n  if (dragOptions?.drawTime !== caller || !dragStart || !dragEnd) {\n    return\n  }\n  const { left, top, width, height } = computeDragRect(\n    chart,\n    options.zoom?.mode,\n    { dragStart, dragEnd },\n    dragOptions.maintainAspectRatio\n  )\n  const ctx = chart.ctx\n\n  ctx.save()\n  ctx.beginPath()\n  ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)'\n  ctx.fillRect(left, top, width, height)\n\n  if (dragOptions.borderWidth) {\n    ctx.lineWidth = dragOptions.borderWidth\n    ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)'\n    ctx.strokeRect(left, top, width, height)\n  }\n  ctx.restore()\n}\n\nconst bindApi = (chart: Chart) => {\n  chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition)\n  chart.zoom = (args, transition) => zoom(chart, args, transition)\n  chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition)\n  chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition)\n  chart.resetZoom = (transition) => resetZoom(chart, transition)\n  chart.getZoomLevel = () => getZoomLevel(chart)\n  chart.getInitialScaleBounds = () => getInitialScaleBounds(chart)\n  chart.getZoomedScaleBounds = () => getZoomedScaleBounds(chart)\n  chart.isZoomedOrPanned = () => isZoomedOrPanned(chart)\n  chart.isZoomingOrPanning = () => isZoomingOrPanning(chart)\n}\n\nexport default {\n  id: 'zoom',\n\n  version,\n\n  defaults,\n\n  start(chart: Chart, _args: unknown, options: ZoomPluginOptions) {\n    const state = getState(chart)\n    state.options = options\n\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn(\n        'The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.'\n      )\n    }\n    if (\n      Object.prototype.hasOwnProperty.call(options.zoom, 'overScaleMode') ||\n      Object.prototype.hasOwnProperty.call(options.pan, 'overScaleMode')\n    ) {\n      console.warn(\n        'The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).'\n      )\n    }\n\n    if (Hammer) {\n      startHammer(chart, options)\n    }\n\n    bindApi(chart)\n  },\n\n  beforeEvent(\n    chart: Chart,\n    { event }: { event: ChartEvent; replay: boolean; cancelable: true; inChartArea: boolean }\n  ): boolean | void {\n    const state = getState(chart)\n    if (isZoomingOrPanningState(state)) {\n      return\n    }\n    // cancel the next click or mouseup after drag or pan\n    if (event.type === 'click' || event.type === 'mouseup') {\n      if (state.filterNextClick) {\n        state.filterNextClick = false\n        return false\n      }\n    }\n  },\n\n  beforeUpdate(chart: Chart, _args: unknown, options: ZoomPluginOptions) {\n    const state = getState(chart)\n    const previousOptions = state.options\n    state.options = options\n\n    // Hammer needs to be restarted when certain options change.\n    if (hammerOptionsChanged(previousOptions, options)) {\n      stopHammer(chart)\n      startHammer(chart, options)\n    }\n\n    addListeners(chart, options)\n  },\n\n  beforeDatasetsDraw(chart: Chart, _args: unknown, options: ZoomPluginOptions) {\n    draw(chart, 'beforeDatasetsDraw', options)\n  },\n\n  afterDatasetsDraw(chart: Chart, _args: unknown, options: ZoomPluginOptions) {\n    draw(chart, 'afterDatasetsDraw', options)\n  },\n\n  beforeDraw(chart: Chart, _args: unknown, options: ZoomPluginOptions) {\n    draw(chart, 'beforeDraw', options)\n  },\n\n  afterDraw(chart: Chart, _args: unknown, options: ZoomPluginOptions) {\n    draw(chart, 'afterDraw', options)\n  },\n\n  stop(chart: Chart) {\n    removeListeners(chart)\n\n    if (Hammer) {\n      stopHammer(chart)\n    }\n    removeState(chart)\n  },\n\n  panFunctions,\n  zoomFunctions,\n  zoomRectFunctions,\n}\n","import type { ZoomPluginOptions } from './options'\n\nexport const defaults: ZoomPluginOptions = {\n  pan: {\n    enabled: false,\n    mode: 'xy',\n    threshold: 10,\n    modifierKey: null,\n  },\n  zoom: {\n    wheel: {\n      enabled: false,\n      speed: 0.1,\n      modifierKey: null,\n    },\n    drag: {\n      enabled: false,\n      drawTime: 'beforeDatasetsDraw',\n      modifierKey: null,\n    },\n    pinch: {\n      enabled: false,\n    },\n    mode: 'xy',\n  },\n}\n","import { Chart } from 'chart.js'\nimport Zoom from './plugin'\n\nChart.register(Zoom)\n\nexport default Zoom\n"],"names":["eventKey","key","getModifierKey","opts","enabled","modifierKey","undefined","keyPressed","event","keyNotPressed","directionEnabled","mode","dir","chart","indexOf","directionsEnabled","x","y","getEnabledScalesByPoint","options","point","scaleMode","overScaleMode","scale","scales","scaleIds","Object","keys","i","length","top","bottom","left","right","getScaleUnderPoint","scaleEnabled","overScaleEnabled","axis","convertOverScaleMode","enabledScales","scaleItem","values","push","getEnabledScales","chartStates","WeakMap","getState","state","get","originalScaleLimits","updatedScaleLimits","handlers","targets","panDelta","dragging","panning","set","isNotNumber","value","isNaN","zoomDelta","val","min","range","newRange","minPercent","isNumber","Math","max","getValueAtPoint","pixel","isHorizontal","getValueForPixel","linearZoomDelta","zoom","center","getLimit","scaleLimits","prop","fallback","limit","original","id","isNullOrUndef","parsed","parse","valueOrDefault","updateRange","limits","scaleOpts","getScaleLimits","minRange","minLimit","Infinity","maxLimit","scaleRange","offset","origLimits","origMin","origMax","epsilon","almostEquals","fixRange","integerChange","v","round","OFFSETS","millisecond","second","minute","hour","day","week","month","quarter","year","panNumericalScale","delta","pan","prevStart","prevEnd","type","isTimeScale","time","newMin","getPixelForValue","newMax","panNonLinearScale","zoomFunctions","category","maxIndex","getLabels","existCategoryFromMaxZoom","default","logarithmic","centerValue","logMin","log10","logMax","logRange","pow","logarithmicZoomRange","zoomRectFunctions","from","to","pixel0","pixel1","v0","v1","linearRange","panFunctions","lastLabelIndex","stepDelta","width","height","scaleLength","stepSize","abs","applied","Boolean","timeseries","shouldUpdateScaleLimits","previous","removeMissingScales","storeOriginalScaleLimits","doZoom","amount","fn","doZoomRect","getCenter","ca","chartArea","transition","trigger","focalPoint","zoomOptions","xEnabled","yEnabled","update","onZoom","zoomRect","p0","p1","getOriginalRange","scaleId","panScale","storedDelta","sign","panOptions","onPan","getInitialScaleBounds","scaleBounds","isZoomingOrPanningState","clamp","removeHandler","handler","target","removeEventListener","addHandler","listener","passive","addEventListener","mouseMove","dragStart","dragEnd","keyDown","getPointPosition","canvas","canvasArea","getBoundingClientRect","clientX","clientY","getRelativePosition","zoomStart","onZoomStart","onZoomRejected","mouseDown","legend","_isPointInArea","button","drag","ownerDocument","window","document","applyMinMaxProps","rect","points","begin","end","getRelativePoints","pointEvents","maintainAspectRatio","aspectRatio","ratio","applyAspectRatio","computeDragRect","chartWidth","chartHeight","zoomX","zoomY","mouseUp","onZoomComplete","threshold","distanceX","distanceY","distance","sqrt","filterNextClick","wheel","cancelable","preventDefault","deltaY","wheelPreconditions","speed","percentage","addDebouncedHandler","name","delay","timeout","clearTimeout","setTimeout","debounce","createEnabler","_recognizer","srcEvent","pointerType","onPanRejected","handlePinch","e","pointers","zoomPercent","pinch","pinchX","pinchY","p","pinchAxes","handlePan","deltaX","panScales","hammers","startHammer","mc","Hammer","Manager","add","Pinch","on","startPinch","endPinch","Pan","enable","onPanStart","startPan","onPanComplete","endPan","stopHammer","remove","destroy","delete","draw","caller","dragOptions","drawTime","ctx","save","beginPath","fillStyle","backgroundColor","fillRect","borderWidth","lineWidth","strokeStyle","borderColor","strokeRect","restore","bindApi","args","zoomScale","resetZoom","scaleOptions","getZoomLevel","origRange","level","getZoomedScaleBounds","isZoomedOrPanned","originalMin","originalMax","isZoomingOrPanning","Zoom","version","defaults","start","_args","prototype","hasOwnProperty","call","console","warn","beforeEvent","beforeUpdate","previousOptions","oldOptions","newOptions","oldPan","oldZoom","newPan","newZoom","hammerOptionsChanged","wheelOptions","addListeners","beforeDatasetsDraw","afterDatasetsDraw","beforeDraw","afterDraw","stop","removeListeners","removeState","Chart","register"],"mappings":"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"}